# NopWriteCloser Package

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Go Version](https://img.shields.io/badge/Go-%3E%3D%201.19-blue)](https://golang.org/)
[![Coverage](https://img.shields.io/badge/Coverage-100%25-brightgreen)]()

Lightweight wrapper that adds no-op Close() semantics to any io.Writer, enabling compatibility with io.WriteCloser interfaces.

---

## Table of Contents

- [Overview](#overview)
- [Key Features](#key-features)
- [Installation](#installation)
- [Architecture](#architecture)
- [Quick Start](#quick-start)
- [Performance](#performance)
- [Use Cases](#use-cases)
- [API Reference](#api-reference)
- [Best Practices](#best-practices)
- [Testing](#testing)
- [Contributing](#contributing)
- [License](#license)

---

## Overview

This package provides a wrapper that implements `io.WriteCloser` for any `io.Writer` by adding a no-op `Close()` method. This is the write-equivalent of Go's standard `io.NopCloser` (which works with readers).

### Design Philosophy

1. **Simplicity**: Single-purpose utility with minimal API surface
2. **Compatibility**: Bridge io.Writer to io.WriteCloser without changing behavior
3. **Safety**: Close() is always safe to call, always returns nil
4. **Zero Overhead**: Thin wrapper with no performance penalty
5. **Predictability**: No hidden behavior, no resource management

---

## Key Features

- **Simple API**: Single function `New(io.Writer) io.WriteCloser`
- **No-Op Close**: Close() always returns nil, never affects underlying writer
- **Zero Dependencies**: Uses only standard library
- **Thread-Safe**: Safe for concurrent use if underlying writer is thread-safe
- **100% Coverage**: 54 specs covering all scenarios
- **Production Ready**: Battle-tested, simple implementation

---

## Installation

```bash
go get github.com/nabbar/golib/ioutils/nopwritecloser
```

---

## Architecture

### Package Structure

```
nopwritecloser/
├── interface.go    # Public API (New function)
└── model.go        # Internal wrapper implementation
```

### Component Diagram

```
┌────────────────────────────────────┐
│    io.WriteCloser Interface        │
│  (Required by some APIs)           │
└──────────────┬─────────────────────┘
               │
    ┌──────────▼──────────┐
    │  nopwritecloser.New │
    │    (wrapper)        │
    └──────────┬──────────┘
               │
    ┌──────────▼──────────┐
    │   Internal wrp      │
    ├─────────────────────┤
    │ Write(p) → w.Write  │ ← Delegate
    │ Close() → nil       │ ← No-op
    └──────────┬──────────┘
               │
    ┌──────────▼──────────┐
    │   io.Writer         │
    │  (bytes.Buffer,     │
    │   os.Stdout, etc.)  │
    └─────────────────────┘
```

### Operation Flow

```
User has io.Writer but API needs io.WriteCloser
       ↓
1. Wrap writer with New(writer)
       ↓
2. Use returned WriteCloser
       ↓
Write(data) called
   ↓
3. Delegate to underlying writer
   Return writer.Write(data)
       ↓
Close() called
   ↓
4. Return nil immediately
   Underlying writer NOT closed
```

---

## Quick Start

```go
package main

import (
    "bytes"
    "fmt"
    "github.com/nabbar/golib/ioutils/nopwritecloser"
)

func main() {
    // Create a buffer (io.Writer)
    buf := &bytes.Buffer{}
    
    // Wrap it as io.WriteCloser with no-op close
    wc := nopwritecloser.New(buf)
    
    // Write data
    wc.Write([]byte("Hello, World!"))
    
    // Close does nothing but satisfies the interface
    wc.Close()
    
    // The underlying buffer is still accessible and writable
    buf.Write([]byte(" Still writing!"))
    
    fmt.Println(buf.String())
    // Output: Hello, World! Still writing!
}
```

## API Reference

### New

```go
func New(w io.Writer) io.WriteCloser
```

Creates a new `io.WriteCloser` that wraps the given `io.Writer`. All Write operations are delegated to the underlying writer. The Close method does nothing and always returns nil.

**Parameters:**
- `w` (io.Writer): The underlying writer to wrap

**Returns:**
- `io.WriteCloser`: A WriteCloser that delegates writes to `w` and has a no-op Close

**Example:**
```go
buf := &bytes.Buffer{}
wc := nopwritecloser.New(buf)
```

### Write

```go
func (wc *WriteCloser) Write(p []byte) (n int, err error)
```

Writes data to the underlying writer. This is delegated directly to the wrapped writer.

**Parameters:**
- `p` ([]byte): The byte slice to write

**Returns:**
- `n` (int): Number of bytes written
- `err` (error): Any error from the underlying writer

### Close

```go
func (wc *WriteCloser) Close() error
```

No-operation close. Always returns nil without affecting the underlying writer.

**Returns:**
- `error`: Always nil

## Usage Examples

### With os.Stdout

```go
package main

import (
    "os"
    "github.com/nabbar/golib/ioutils/nopwritecloser"
)

func main() {
    // Wrap stdout so it can be used where WriteCloser is required
    // but we don't want to actually close stdout
    wc := nopwritecloser.New(os.Stdout)
    
    wc.Write([]byte("This goes to stdout\n"))
    wc.Close() // Safe - doesn't close stdout
    
    // Can continue using stdout
    os.Stdout.Write([]byte("Still works!\n"))
}
```

### With JSON Encoding

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "github.com/nabbar/golib/ioutils/nopwritecloser"
)

func writeJSON(wc io.WriteCloser, data interface{}) error {
    encoder := json.NewEncoder(wc)
    err := encoder.Encode(data)
    wc.Close() // Safe - doesn't close underlying buffer
    return err
}

func main() {
    buf := &bytes.Buffer{}
    wc := nopwritecloser.New(buf)
    
    data := map[string]string{"message": "Hello, JSON!"}
    writeJSON(wc, data)
    
    // Buffer is still accessible
    fmt.Println(buf.String())
}
```

### With HTTP Response Writer Wrapper

```go
package main

import (
    "compress/gzip"
    "net/http"
    "github.com/nabbar/golib/ioutils/nopwritecloser"
)

func handler(w http.ResponseWriter, r *http.Request) {
    // Create gzip writer
    gz := gzip.NewWriter(nopwritecloser.New(w))
    defer gz.Close()
    
    // Write compressed response
    gz.Write([]byte("Compressed response"))
    
    // nopwritecloser prevents gzip.Close from closing the ResponseWriter
}
```

### With Shared Buffer

```go
package main

import (
    "bytes"
    "fmt"
    "github.com/nabbar/golib/ioutils/nopwritecloser"
)

func writeSection(wc io.WriteCloser, section string) {
    fmt.Fprintf(wc, "[%s]\n", section)
    wc.Close() // Safe - doesn't close the shared buffer
}

func main() {
    buf := &bytes.Buffer{}
    wc := nopwritecloser.New(buf)
    
    // Multiple functions can write to the same buffer
    writeSection(wc, "Header")
    writeSection(wc, "Body")
    writeSection(wc, "Footer")
    
    fmt.Println(buf.String())
}
```

### With Multi-Writer

```go
package main

import (
    "bytes"
    "io"
    "os"
    "github.com/nabbar/golib/ioutils/nopwritecloser"
)

func main() {
    buf := &bytes.Buffer{}
    
    // Write to both stdout and buffer without closing either
    multi := io.MultiWriter(
        nopwritecloser.New(os.Stdout),
        nopwritecloser.New(buf),
    )
    
    wc := nopwritecloser.New(multi)
    wc.Write([]byte("Logged to both!\n"))
    wc.Close() // Safe - doesn't close stdout or buffer
}
```

### As a Logger Sink

```go
package main

import (
    "bytes"
    "fmt"
    "log"
    "github.com/nabbar/golib/ioutils/nopwritecloser"
)

func processWithLogging(wc io.WriteCloser) {
    logger := log.New(wc, "[PROCESS] ", log.LstdFlags)
    
    logger.Println("Starting process")
    // Do work...
    logger.Println("Process complete")
    
    wc.Close() // Doesn't affect the underlying buffer
}

func main() {
    buf := &bytes.Buffer{}
    wc := nopwritecloser.New(buf)
    
    processWithLogging(wc)
    
    // Retrieve logs
    fmt.Println("Captured logs:")
    fmt.Println(buf.String())
}
```

## Use Cases

### 1. API Compatibility

When a function or library requires an `io.WriteCloser` but you're using a writer that you don't want to close:

```go
func processData(wc io.WriteCloser) {
    // Function expects WriteCloser
    defer wc.Close()
    // ... write data ...
}

// Your writer that shouldn't be closed
buf := &bytes.Buffer{}
processData(nopwritecloser.New(buf))
// buf is still usable here
```

### 2. Shared Resources

When multiple components need to write to the same resource but shouldn't close it:

```go
var logBuffer bytes.Buffer

func writeLog(source string, wc io.WriteCloser) {
    defer wc.Close() // Safe to call
    fmt.Fprintf(wc, "[%s] Log entry\n", source)
}

wc := nopwritecloser.New(&logBuffer)
writeLog("module1", wc)
writeLog("module2", wc)
writeLog("module3", wc)
```

### 3. Testing

When testing functions that close their writers but you want to inspect the output:

```go
func TestWriter(t *testing.T) {
    buf := &bytes.Buffer{}
    wc := nopwritecloser.New(buf)
    
    functionThatCloses(wc) // Calls Close() internally
    
    // Can still inspect buffer content
    if !strings.Contains(buf.String(), "expected") {
        t.Error("Output doesn't contain expected text")
    }
}
```

### 4. Standard Output/Error Protection

When you need to pass stdout/stderr to functions that close their writers:

```go
func writeOutput(wc io.WriteCloser) {
    defer wc.Close() // Would close stdout!
    wc.Write([]byte("Output\n"))
}

// Protect stdout from being closed
writeOutput(nopwritecloser.New(os.Stdout))
```

## Thread Safety

`nopwritecloser` itself is thread-safe for concurrent calls to `Write()` and `Close()` **only if the underlying writer is thread-safe**. The wrapper adds no synchronization overhead.

**Thread-Safe Example:**
```go
buf := &safeBuffer{} // Assumes safeBuffer has internal locking
wc := nopwritecloser.New(buf)

// Safe concurrent access
go wc.Write([]byte("goroutine 1"))
go wc.Write([]byte("goroutine 2"))
```

**Not Thread-Safe Example:**
```go
buf := &bytes.Buffer{} // bytes.Buffer is not thread-safe
wc := nopwritecloser.New(buf)

// Unsafe - will cause data races
go wc.Write([]byte("goroutine 1"))
go wc.Write([]byte("goroutine 2"))
```

## Behavior

### Write Behavior

- Writes are passed directly to the underlying writer
- Returns the exact result (bytes written, error) from the underlying writer
- No buffering or modification of data

### Close Behavior

- Always returns `nil`
- Never affects the underlying writer
- Can be called multiple times safely
- Writes are still possible after Close

### After Close

Unlike many `io.WriteCloser` implementations, you can continue writing after calling Close:

```go
wc := nopwritecloser.New(buf)
wc.Write([]byte("before"))
wc.Close()
wc.Write([]byte("after")) // This works!
```

## Comparison with io.NopCloser

| Feature | nopwritecloser | io.NopCloser |
|---------|---------------|--------------|
| Input | io.Writer | io.Reader |
| Output | io.WriteCloser | io.ReadCloser |
| Close behavior | No-op | No-op |
| Standard library | No | Yes |

## Performance

- **Zero Allocation**: After initial creation, no additional allocations
- **Zero Copy**: Data passes through without copying
- **Minimal Overhead**: Single function call delegation
- **No Buffering**: Writes go directly to underlying writer

## Limitations

1. **No Actual Closing**: If you actually need to close the underlying writer, don't use this package
2. **No Resource Cleanup**: Won't trigger any cleanup that Close() might normally do
3. **Thread Safety Depends on Writer**: Not thread-safe if underlying writer isn't thread-safe

## Best Practices

1. **Use When Appropriate**: Only use when you genuinely don't want to close the underlying writer
2. **Document Behavior**: Make it clear in your code why you're using nopwritecloser
3. **Consider Alternatives**: If you need actual close behavior, use the raw writer or a different wrapper
4. **Thread Safety**: Ensure thread safety at the underlying writer level if needed

## Error Handling

The wrapper propagates all errors from the underlying writer without modification:

```go
errWriter := &alwaysErrorWriter{}
wc := nopwritecloser.New(errWriter)

n, err := wc.Write([]byte("test"))
// err will be the error from errWriter, unmodified
```

## License

MIT License - See LICENSE file for details

## Contributing

Contributions are welcome! Please ensure:
- All tests pass (`go test ./...`)
- Code coverage remains at 100%
- Race detector passes (`go test -race ./...`)
- Code follows Go best practices

## Related Packages

- **io.NopCloser**: Standard library equivalent for readers
- **io.Discard**: For writes that should be discarded
- **io.MultiWriter**: For writing to multiple destinations

## Support

For issues or questions:
- Check existing tests for usage examples
- Review the documentation above
- Report bugs to the golib repository
